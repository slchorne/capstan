

Overview:

The objective is to get valid 'Trust Anchors' into the
    Grid DNS Properties -> DNSSec -> Trust Anchors

RFC 5011 says that delegation ponts can publish their DNSKEYS in a way
that allows them to roll their keys and subscribers can grab the keys
and, presumably trust them.

In this context the trust anchors are KSKs for non-authoritative zones.
And thus used by the resolver component of the nameserver

As per the spec it Should only manage anchors for known trust points and
only for keys that have the SEP bit set

-----------------------------------
Ulf:

[ ] need to manually add the initial key
    user types it in, we check it with a DNS query 
    [ ] -a needs a key as well
        [ ] read from an input file, use ALL keys from the
            file for that zone

[ ] validation
    Must bootstrap from a known trust anchor
    check the DNSKEYset with the RRSIG
    [ ] must start with a key, 
    [ ] and always validate from known KEYS only.

        [ ] use the same format as our 'export trust anchor'
            format, which is 'dig + multiline' rolled back
            into a single line

    [ ] never add a key that wasn't checked by a trusted key
    [ ] must also validate revoked keys with the same keyset
[ ] hold-down - 30 days ?
    yes, but checking more frequently helps with the revocation
    process
    [ ] if we run every hour, we can ignore TTLS
[ ] revoke , YES, not neg anchors
[ ] system changes - what if invalid ?
    only follow managed trust points

-----------------------------------
Design and implementation

Capstan

[ ] locking
    [ ] need to lock the script in case someone tries an admin function
        while it is processing from a cron job ?

    [ ] or are there no risks of collisions, anyway ?

[ ] Command line options

    [x] --init  # initialise the zone, storage etc
    [x] -C  # show the config
    [x] -m  # set the Nameserver member
            # and list all members if none set
    [ ] -p  # passive, don't restart services
    [ ] -t  # test all key states ( doesn't modify database )
    [ ] -s  # re-sync all keys (quite the hammer)
    [x] -a  # add a domain
    [ ] -v  # view ( add domain to just this view )
    [x] -r  # remove a domain
    [x] -l  # list domains
    [x] -k  # list all key states
    [x] --user   # add/configure the login account

[x] need a nameserver to resolve the KSKs 
    [x] set an EA on one of the members.

[ ] grid or MEMBER level anchors, not views
    [ ] how to set the location ?

[-] REST API ? 
    NOT supported for trust anchors, need to use PAPI.

[x] state storage
    [x] don't bother with the overhead of localDb
    [-] Just store all the pending key info in a text file on disk
        or use 'storable' ?

    [x] login info needs to be on the entiry,
        [x] use storable to keep the config for the useraccount
            [-] just store the HTTP header info

    [x] store the KEY info in 'RFC5011.local' zone
        [x] use TXT records and the REST api 
        [x] don't add any nameservers to the zone, disable it
        [x] ALWAYS in the default view

    [x] auto-configure the zone on init, first run

    [ ] only store the active keys on the grid,
        put the rest of the config into the zone

[x] re-verify any of the records when reading from the file, so you don't
risk someone replacing with data with bad data
    [x] don't store the keys or signatures
    [x] only store the required fields to re-do the lookup,
        [x] key id = 33878

[ ] pull any new keys added to the grid from outside this process...

[ ] we should validate the signing of the key, not just plain import it
    [ ] need to walk the signing chain

[ ] Platform the entity will run on is LINUX.

[ ] CRON or Daemon
    [ ] Periodic intervals for running the script is OK for T-Systems.
    [ ] Run as a cron job at a fine grained period.
        smaller than the window of the sleep timers

        "Given that the minimum refresh time is one hour, such a fixed
        interval should be one hour in order to conform to the RFC"

[ ] pending keys get stored in the dataset until they are considered valid
    [ ] just follow the rules of the statemachine

[-] can't use a pure-perl net::dns::sec - will be platform dependent. ?

------------
General notes:

What they want is something like trustMan: ?

https://www.dnssec-tools.org/wiki/index.php/Trustman 

[x] do we care about pending keys ? Is this something that we can rely on
from bind ? If the key appears, then disappears later, who cares, the
entity will just add/remove it right ?
    [x] or is this related to the 'bad key' injection problem ?
    [x] yes, since you can't really trust the nameserver chain of query

Validation works because you have to SIGN the WHOLE RRset.

So if you have a set or keys A,B
and if someone adds a new key, C they can sign the whole NEW set [a,b,c]
and produce a valid signature.

But the other signature for the same rrset, won't contain C, it will only
contain [a,b] and the signature will fail when we try and validate
[a,b,c].

And the new key can never be signed by the old key, because they don't
have the private key to sign it

the problem, thus, is that the INVALID key, may be the GOOD key, (because
the RRSet is invalid) so you have to invalidate ALL keys.

BUT - what do you do then ? Stop trusting the zone ?

BUT - what if the old sig is missing from the rrset ?
BUT - what if the rrset just has whole new keys and sigs ?



