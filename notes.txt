

Overview:

The objective is to get valid 'Trust Anchors' into the
    Grid DNS Properties -> DNSSec -> Trust Anchors

RFC 5011 says that delegation ponts can publish their DNSKEYS in a way
that allows them to roll their keys and subscribers can grab the keys
and, presumably trust them.

In this context the trust anchors are KSKs for non-authoritative zones.
And thus used by the resolver component of the nameserver

As per the spec it Should only manage anchors for known trust points and
only for keys that have the SEP bit set

Speaking to Ulf Ekberg, fron the BIND/Eng side of things:

If we check everything every hour we are well within any hold-down timers
and revocation timers, so there is no need for an adavnced TTL monitor,
just re-check everything 1/hour

You can't add a domain to trust unless you also provide a key for that
domain, this MUSt be an out of band operation to bootstrap the process.
This key will also be used to validate any new keys

-----------------------------------
Design and implementation

Capstan

[ ] locking
    [ ] need to lock the script in case someone tries an admin function
        while it is processing from a cron job ?

    [ ] or are there no risks of collisions, anyway ?

[ ] Command line options

    [x] --init  # initialise the zone, storage etc
    [x] -C  # show the config

    [ ] -ns  # set the Nameserver member
             # and list all members if none set

    [ ] -p  # passive, don't restart services
    [ ] -t  # test all key states ( doesn't modify database )
    [ ] -s  # re-sync all keys (quite the hammer)
            # rebuilds from a dead/broken script
    [x] -a  # add a domain
    [ ] -v  # view ( add domain to just this view )
    [ ] -m  # member ( add domain to just this member )
    [x] -r  # remove a domain
    [x] -l  # list domains
    [x] -k  # list all key states
    [x] --user   # add/configure the login account

[ ] add a domain
    You must bootstrap a domain with a known key
    [ ] a key must already exist in the grid properties
        [ ] use this key for bootstrap
    [ ] just adds it to the tracker,
    [ ] report existing domains as part of --init

[x] need a nameserver to resolve the KSKs 
    [x] set an EA on one of the members.

[ ] validation
    [ ] a RRSIG applies to all DNSKEYS
    [ ] validate a sig by the matching key
    [ ] use the keytag (id) to match key <-> signature

    [ ] and always validate from known KEYS only.
    [ ] never add a key that wasn't checked by a trusted key

[ ] grid or MEMBER level anchors, not views
    [ ] how to set the location ?

[-] REST API ? 
    NOT supported for trust anchors, need to use PAPI.

[x] state storage
    [x] don't bother with the overhead of localDb
    [-] Just store all the pending key info in a text file on disk
        or use 'storable' ?

    [x] login info needs to be on the entiry as a local file,
        [x] use storable to keep the config for the useraccount
            [-] just store the HTTP header info

    [ ] store the DNS QUERY member as an EA on the member
            RFC5011 == 'nameserver'
    [ ] store a managed member as an EA on the member
            RFC5011Managed == 'true'

    [x] store the KEY and Domain info in 'RFC5011.local' zone
        [x] don't add any nameservers to the zone, disable it
        [x] use TXT records and the PAPI
            ( REST would be better, but it simplifies syntax )
        [x] the zone is ALWAYS in the default view

        [ ] need to track records for both grid and other levels
            so dotted names aren't going to directly cut it
            [ ] default.grid.RFC5011.infoblox.local
                RFC5011Managed == 'grid'
                RFC5011Location == 'grid'
            [ ] member.name.member.RFC5011.infoblox.local
                RFC5011Managed == 'member'
                RFC5011Location == 'member.name'
            [ ] view.name.view.RFC5011.infoblox.local
                RFC5011Managed == 'view'
                RFC5011Location == 'view.name'

        [ ] add the domain as 'domain.grid|member.namespace'
            RFC5011Managed == 'grid|member'
            RFC5011 == 'domain'
        [ ] add the key as 'ID.key.domain.grid|member.namespace'
            RFC5011 == 'grid'

    [x] auto-configure the zone on init, first run

    [ ] only store the active keys on the grid,
        put the rest of the config into the zone

[x] re-verify any of the records when reading from the file, so you don't
risk someone replacing with data with bad data
    [x] don't store the keys or signatures
    [x] only store the required fields to re-do the lookup,
        [x] key id = 33878

[ ] pull any new keys added to the grid from outside this process...
    [ ] ONLY if they are part of a tracked domain,
        [ ] validate these keys
    [ ] this can also be used to bootstrap a new domain

[ ] we should validate the signing of the key, not just plain import it
    [ ] need to walk the signing chain

[ ] Platform the entity will run on is LINUX.

[ ] CRON or Daemon
    [ ] Periodic intervals for running the script is OK for T-Systems.
    [ ] Run as a cron job at a fine grained period.
        smaller than the window of the sleep timers
        smaller than the window of the revocation windows

        "Given that the minimum refresh time is one hour, such a fixed
        interval should be one hour in order to conform to the RFC"

[ ] pending keys get stored in the dataset until they are considered valid
    [ ] just follow the rules of the statemachine

[ ] revoking keys - 
    [ ] a revoked key must still be in the signed list
        ( as this is how the owner verifies this key )
        [ ] revoked mey must pass validation
    [ ] check statemachine for revokation rules

[-] can't use a pure-perl net::dns::sec - will be platform dependent. ?

------------
General notes:

What they want is something like trustMan: ?

https://www.dnssec-tools.org/wiki/index.php/Trustman 

[x] do we care about pending keys ? Is this something that we can rely on
from bind ? If the key appears, then disappears later, who cares, the
entity will just add/remove it right ?
    [x] or is this related to the 'bad key' injection problem ?
    [x] yes, since you can't really trust the nameserver chain of query

Validation works because you have to SIGN the WHOLE RRset.

So if you have a set or keys A,B
and if someone adds a new key, C they can sign the whole NEW set [a,b,c]
and produce a valid signature.

But the other signature for the same rrset, won't contain C, it will only
contain [a,b] and the signature will fail when we try and validate
[a,b,c].

And the new key can never be signed by the old key, because they don't
have the private key to sign it

the problem, thus, is that the INVALID key, may be the GOOD key, (because
the RRSet is invalid) so you have to invalidate ALL keys.

BUT - what do you do then ? Stop trusting the zone ?

BUT - what if the old sig is missing from the rrset ?
BUT - what if the rrset just has whole new keys and sigs ?



