
Overview:

The objective is to get valid 'Trust Anchors' into the
    Grid DNS Properties -> DNSSec -> Trust Anchors

RFC 5011 says that delegation ponts can publish their DNSKEYS in a way
that allows them to roll their keys and subscribers can grab the keys
and, presumably trust them.

In this context the trust anchors are KSKs for non-authoritative zones.
And thus used by the resolver component of the nameserver

As per the spec it Should only manage anchors for known trust points and
only for keys that have the SEP bit set

Speaking to Ulf Ekberg @infoblox.com, from the BIND/Eng side of things:

If we check everything every hour we are well within any hold-down timers
and revocation timers, so there is no need for an adavnced TTL monitor,
just re-check everything 1/hour

You can't add a domain to trust unless you also provide a key for that
domain, this MUST be an out of band operation to bootstrap the process.
This key will also be used to validate any new keys

-----------------------------------
Design and implementation

Capstan

[ ] publish to github

[ ] testing
    [t] bad DNS resolver
        ./capstan.pl

    [t] add a domain
        [t] add domain with 1 key
        [t] add domain with all keys
        ./capstan.pl -a org -x 208.69.40.3

    [t] remove a domain
        ./capstan.pl -r org 

    [t] publish pending keys
        [t] no domains configured
        [t] some domains configured
        ./capstan.pl -x 208.69.40.3

    [x] create some fake events...
        [ ] need a '-t miss|add|revoke|remove' hidden command

    [t] track a missing key
        ./capstan.pl -x 208.69.40.3 -t miss
    [t] add a new key
        [x] remove a new key
        ./capstan.pl -x 208.69.40.3 -t new
        ./capstan.pl -x 208.69.40.3

    [x] revoke a key
        ./capstan.pl -x 208.69.40.3 -t revoke
         id : 9795
        
    [x] remove a key
        ./capstan.pl -x 208.69.40.3 -t remove

    [x] delete a key
        ./capstan.pl -x 208.69.40.3 -t remove



[x] digests and tags
    the keytag could be calcuated and used instead of the digest
    But the tag changes if the key is revoked (as it's calculated from
    the flags.

    [x] use a variation of the one defined in RFC4034
    Appendix B, with the 'flags','protocol' and 'algorithm' are all set
    to 0.

[ ] locking
    [ ] need to lock the script in case someone tries an admin function
        while it is processing from a cron job ?

    [ ] or are there no risks of collisions, anyway ?
        since admin functions don't add/remove anchors

[ ] Command line options

    [x] --init  # initialise the zone, storage etc
    [x] -C  # show the config

    [ ] -ns  # set the Nameserver member
             # and list all members if none set

    [ ] -p  # passive, don't restart services
    [ ] -t  # test all key states ( doesn't modify database )
    [ ] -s  # re-sync all keys (quite the hammer)
            # rebuilds from a dead/broken script
    [x] -a  # add a domain

    [ ] -v  # view ( add domain to just this view )
    [ ] -m  # member ( add domain to just this member )

    [x] -r  # remove a domain
    [x] -l  # list domains
    [x] -k  # list all key states
    [x] --user   # add/configure the login account

[x] add a domain
    You must bootstrap a domain with a known key
    [x] a key must already exist in the grid properties
        [x] use this key for bootstrap
    [x] just adds it to the tracker,

    [-] report discovered domains as part of --init ?
        Nah, just use '-l'

[x] need a nameserver to resolve the KSKs 
    [x] set an EA on one of the members.

[ ] validation
    [x] a RRSIG applies to all DNSKEYS
    [x] validate a sig by the matching key
    [x] use the keytag (id) to match key <-> signature

    [ ] and always validate from known KEYS only.
    [ ] never add a key that wasn't checked by a trusted key

[ ] grid or MEMBER level anchors, not views ?
    [x] how to set the location ?
        EAs, and insert into the TXT FQDN

[-] REST API ? 
    NOT supported for trust anchors, need to use PAPI.

[x] state storage
    [x] don't bother with the overhead of localDb
    [-] Just store all the pending key info in a text file on disk
        or use 'storable' ?

    [x] login info needs to be on the entiry as a local file,
        [x] use storable to keep the config for the useraccount
            [-] just store the HTTP header info

    [x] store the DNS QUERY member as an EA on the member
            RFC5011 == 'nameserver'
    [ ] store a managed member as an EA on the member
            RFC5011Managed == 'true'

    [x] store the KEY and Domain info in 'RFC5011.local' zone
        [x] don't add any nameservers to the zone, disable it
        [x] use TXT records and the PAPI
            ( REST would be better, but it simplifies syntax )
        [x] the zone is ALWAYS in the default view

        [ ] need to track records for both grid and other levels
            so dotted names aren't going to directly cut it
            [ ] default.grid.RFC5011.infoblox.local
                RFC5011Managed == 'grid'
                RFC5011Location == 'grid'
            [ ] member.name.member.RFC5011.infoblox.local
                RFC5011Managed == 'member'
                RFC5011Location == 'member.name'
            [ ] view.name.view.RFC5011.infoblox.local
                RFC5011Managed == 'view'
                RFC5011Location == 'view.name'

        [ ] add the domain as 'domain.grid|member.namespace'
            RFC5011Managed == 'grid|member'
            RFC5011 == 'domain'
        [ ] add the key as 'ID.key.domain.grid|member.namespace'
            RFC5011 == 'grid'

    [x] auto-configure the zone on init, first run

    [x] only store the active trust anchors on the grid,
        put the rest of the config into the zone

[x] re-verify any of the records when reading from the file, so you don't
risk someone replacing with data with bad data
    [x] don't store the keys or signatures
    [x] only store the required fields to re-do the lookup,
        [x] key id = 33878

[x] pull any new keys added to the grid from outside this process...
    [x] ONLY if they are part of a tracked domain,
        [x] validate these keys
    [x] this can also be used to bootstrap a new domain

[x] we should validate the signing of the key, not just plain import it
    [-] need to walk the signing chain

[ ] CRON or Daemon ?
    [ ] document the CRON setup

    [ ] Run as a cron job at a fine grained period.
        smaller than the window of the sleep timers
        smaller than the window of the revocation windows

        "Given that the minimum refresh time is one hour, such a fixed
        interval should be one hour in order to conform to the RFC"

[ ] pending keys get stored in the dataset until they are considered valid
    [x] just follow the rules of the statemachine

[ ] revoking keys - 
    [ ] a revoked key must still be in the signed list
        ( as this is how the owner verifies this key )
        [ ] revoked key must pass validation
    [x] check statemachine for revokation rules

[-] can't use a pure-perl net::dns::sec - will be platform dependent. ?

