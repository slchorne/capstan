
Overview:

The objective is to get valid 'Trust Anchors' into the
    Grid DNS Properties -> DNSSec -> Trust Anchors

RFC 5011 says that delegation ponts can publish their DNSKEYS in a way
that allows them to roll their keys and subscribers can grab the keys
and, presumably trust them.

In this context the trust anchors are KSKs for non-authoritative zones.
And thus used by the resolver component of the nameserver

As per the spec it Should only manage anchors for known trust points and
only for keys that have the SEP bit set

Speaking to Ulf Ekberg @infoblox.com, from the BIND/Eng side of things:

If we check everything every hour we are well within any hold-down timers
and revocation timers, so there is no need for an adavnced TTL monitor,
just re-check everything 1/hour

You can't add a domain to trust unless you also provide a key for that
domain, this MUST be an out of band operation to bootstrap the process.
This key will also be used to validate any new keys

-----------------------------------
Design and implementation

Capstan

[ ] publish to github

[x] Re-do a test from scratch

[ ] finish the perl doc
    [ ] readme.pod (works with github)
    perldoc -u capstan.pl > README.pod

[x] Demo

[ ] clean up some messages
    state : 8763 tag[9795] : unknown revoked -> valid
                             ^^^^^^^^^^^^^^
    state : 8763 tag[9795] : pending -> valid : offhold
                                                ^^^^^^^        
    state : 8763 tag[9795] : pending -> onhold
                                        ^^^^^^

[x] testing

    basic test or demo plan

    make the nameserver recurse to the real world

        # move the org key from the grid
    ./capstan.pl --init
    ./capstan.pl --init --gm 10.64.128.20 --user admin 
    ./capstan.pl --init --gm 10.64.128.20 --user admin -f
    ./capstan.pl --init --gm 10.64.128.20 --user admin --pass infoblox -f
    ./capstan.pl -a org -x 208.69.40.3
        # move the org key back into place
    ./capstan.pl -a org -x 208.69.40.3
    ./capstan.pl -r org
    ./capstan.pl -a org -x 208.69.40.3
    ./capstan.pl -x 208.69.40.3
        # wait 30 secs
    ./capstan.pl -x 208.69.40.3
        # remove one of the keys from the zone
    ./capstan.pl -x 208.69.40.3
        # wait 30 secs
    ./capstan.pl -x 208.69.40.3
    ./capstan.pl -x 208.69.40.3 -w new
    ./capstan.pl -x 208.69.40.3
    ./capstan.pl -x 208.69.40.3 -w revoke
    ./capstan.pl -x 208.69.40.3 -w remove
    ./capstan.pl -x 208.69.40.3 -w miss
        # wait 30 secs
    ./capstan.pl -x 208.69.40.3
        # wait 30 secs
    ./capstan.pl -x 208.69.40.3

    [t] bad DNS resolver
        ./capstan.pl

    [t] add a domain
        [t] add domain with 1 key
        [t] add domain with all keys
        ./capstan.pl -a org -x 208.69.40.3

    [t] remove a domain
        ./capstan.pl -r org 

    [t] publish pending keys
        [t] no domains configured
        [t] some domains configured
        ./capstan.pl -x 208.69.40.3

    [x] create some fake events...
        [x] need a '-w miss|add|revoke|remove' hidden command

    [t] track a missing key
        ./capstan.pl -x 208.69.40.3 -w miss

    [t] add a new key
        [x] remove a new key
        ./capstan.pl -x 208.69.40.3 -w new
        ./capstan.pl -x 208.69.40.3

    [t] revoke a key
        ./capstan.pl -x 208.69.40.3 -w revoke
         id : 9795
        
    [t] remove a key
        ./capstan.pl -x 208.69.40.3 -w remove

    [-] invalid key 
        treated as missing
        but fake an error message in the right place
        ./capstan.pl -x 208.69.40.3 -w invalid
        keystate == 'error'

    [-] unsigned key 
        treated as missing
        keystate == 'nosig'

[x] digests and tags
    the keytag could be calcuated and used instead of the digest
    But the tag changes if the key is revoked (as it's calculated from
    the flags.

    [x] use a variation of the one defined in RFC4034
    Appendix B, with the 'flags','protocol' and 'algorithm' are all set
    to 0.

[ ] locking
    [ ] need to lock the script in case someone tries an admin function
        while it is processing from a cron job ?

    [ ] or are there no risks of collisions, anyway ?
        since admin functions don't add/remove anchors

[ ] Command line options

    [x] --init  # initialise the zone, storage etc
    [x] -C  # show the config

    [x] -ns  # set the Nameserver member
             # and list all members if none set

    [x] -p  # passive, don't restart services
    [x] -t  # test all key states ( doesn't modify database )
    [-] -s  # re-sync all keys (quite the hammer)
            # rebuilds from a dead/broken script

        This mode isn't required since the normal state machine
        just handles things correctly as it keys off the 
        current trust anchors

        worst case you add and remove the zones ?

            # only active trust anchors are validated, 
            # and any other revoked keys are kept
            # any other keys are removed from the system

    [x] -a  # add a domain

    [x] -v  # view ( add domain to just this view )
    [x] -m  # member ( add domain to just this member )

    [x] -r  # remove a domain
    [x] -l  # list domains
    [x] -k  # list all key states
    [x] --user   # add/configure the login account

    [x] -x n.n.n.n use different resolver
    [x] -w <state> fake DNS states on RRs

[x] add a domain
    You must bootstrap a domain with a known key
    [x] a key must already exist in the grid properties
        [x] use this key for bootstrap
    [x] just adds it to the tracker,

    [-] report discovered domains as part of --init ?
        Nah, just use '-l'

[x] need a nameserver to resolve the KSKs 
    [x] set an EA on one of the members.

[x] merge validateAnchor() and validateDomainKeys()
    [x] check for invalid keys in the grid

[x] track missing keys
    count how long it has been missing

[ ] validation
    [x] a RRSIG applies to all DNSKEYS
    [x] validate a sig by the matching key
    [x] use the keytag (id) to match key <-> signature

    [x] revoked keys still need to be valid

    [x] always validate from known KEYS only.
        [x] compare the queried key to a key in the grid
            use that to match trusted keys
        [x] never add a key that wasn't checked by a trusted key

        [x] if a key fails validation, that key is bad,
            and impicitly the keyset may end up bad,
            when all keys fail.

        [x] injected (bad) keys will never make it
            into the RRSEt, until they are in a valid
            signature, signed by a known key

            [x] report errors with injected keys
                (These could be new keys on hold)
                
    [x] A key that fails to validate the set is invalid
    [x] A key with no signature is invalid

    [x] An invalid key is considered missing
        because it is not in the 'validated DNSKEY RRSet'

[x] grid or MEMBER level anchors, not views ?
    [x] need to store grid/member/view in getAnchors();

    [x] Fix ALL calls to getanchors...
    [x] Fix ALL refs to $conf->anchors

    [x] need a way to get a REF to the
        DNS props when calling 'pub/discokey'

        - Need a single call.
        [x] call my $obj = getDNSSettings( $conf , $level , $name )
        [x] call my $adata = getObjectAnchors ( $obj );

        [x] We ALWAYS know the level and name so just
            pass it to a generic getDNSSettings() call

        [-] Can we use this for getAnchors ??
            No - because one is specific and
            one gets ALL settings

    [x] tag the view
        RFC5011Level = 'view'
    [x] tag the member, 
        RFC5011Level = 'member'
        [x] need to do this on the GRID menber, can't set it
            on any DNS props

[-] REST API ? 
    NOT supported for trust anchors, need to use PAPI.

[x] state storage
    [x] don't bother with the overhead of localDb
    [-] Just store all the pending key info in a text file on disk
        or use 'storable' ?

    [x] login info needs to be on the entiry as a local file,
        [x] use storable to keep the config for the useraccount
            [-] just store the HTTP header info

    [x] store the DNS QUERY member as an EA on the member
            RFC5011 == 'nameserver'
    [x] store a managed member as an EA on the member
            RFC5011Managed == 'true'

    [x] store the KEY and Domain info in 'RFC5011.local' zone
        [x] don't add any nameservers to the zone, disable it
        [x] use TXT records and the PAPI
            ( REST would be better, but it simplifies syntax )
        [x] the zone is ALWAYS in the default view

        [x] need to track records for both grid and other levels
            so dotted names aren't going to directly cut it
            [x] default.griLevel.RFC5011.infoblox.local
                RFC5011Level == 'grid'
                RFC5011Name == 'grid'
                RFC5011Type == 'key'
            [x] member.name.member.RFC5011.infoblox.local
                RFC5011Level == 'member'
                RFC5011Name == 'member.name'
                RFC5011Type == 'key'
            [x] view.name.view.RFC5011.infoblox.local
                RFC5011Level == 'view'
                RFC5011Name == 'view.name'
                RFC5011Type == 'key'

        [x] add the domain as 'domain.grid|member.namespace'
                RFC5011Level == '|member|view'
                RFC5011Name == 'view.name'
                RFC5011Type == 'domain'

    [x] auto-configure the zone on init, first run

    [x] only store the active trust anchors on the grid,
        put the rest of the config into the zone

[x] re-verify any of the records when reading from the file, so you don't
risk someone replacing with data with bad data
    [x] don't store the keys or signatures
    [x] only store the required fields to re-do the lookup,
        [x] key id = 33878

[x] pull any new keys added to the grid from outside this process...
    [x] ONLY if they are part of a tracked domain,
        [x] validate these keys
    [x] this can also be used to bootstrap a new domain

[x] we should validate the signing of the key, not just plain import it
    [-] need to walk the signing chain

[ ] CRON or Daemon ?
    [ ] document the CRON setup

    [ ] Run as a cron job at a fine grained period.
        smaller than the window of the sleep timers
        smaller than the window of the revocation windows

        "Given that the minimum refresh time is one hour, such a fixed
        interval should be one hour in order to conform to the RFC"

[x] pending keys get stored in the dataset until they are considered valid
    [x] just follow the rules of the statemachine

[x] revoking keys - 
    [x] a revoked key must still be in the signed list
        ( as this is how the owner verifies this key )
        [x] revoked key must pass validation
    [x] check statemachine for revokation rules

[-] can't use a pure-perl net::dns::sec - will be platform dependent. ?

